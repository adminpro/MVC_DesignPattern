using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.Http.Filters;
using System.IO.Compression;

namespace MVC_DesignPattern.Filters
{
    [AttributeUsage(AttributeTargets.Class|AttributeTargets.Method, AllowMultiple = false)]
    public class CompressAttribute : ActionFilterAttribute
    {
        /// <summary>
        /// Override to compress the content that is generated by
        /// an action method.
        /// </summary>
        /// <param name="actionContext"></param>
        public override void OnActionExecuting(System.Web.Http.Controllers.HttpActionContext actionContext)
        {
            GZipEncodePage();
        }

        /// <summary>
        /// Determines if GZip is supported
        /// </summary>
        /// <returns></returns>
        public static bool IsGZipSupported()
        {
            string AcceptEncoding = HttpContext.Current.Request.Headers["Accept-Encoding"];
            if (!string.IsNullOrEmpty(AcceptEncoding) &&
                    (AcceptEncoding.Contains("gzip") || AcceptEncoding.Contains("deflate")))
                return true;
            return false;

        }

        /// <summary>
        /// Sets up the current page or handler to use GZip through a Response.Filter
        /// IMPORTANT:  
        /// You have to call this method before any output is generated!
        /// </summary>
        public static void GZipEncodePage()
        {
            HttpResponse Response = HttpContext.Current.Response;

            if (IsGZipSupported())
            {
                string AcceptEncoding = HttpContext.Current.Request.Headers["Accept-Encoding"];

                if (AcceptEncoding.Contains("gzip"))
                {
                    Response.Filter = new System.IO.Compression.GZipStream(Response.Filter,
                                                System.IO.Compression.CompressionMode.Compress);
                    Response.Headers.Remove("Content-Encoding");
                    Response.AppendHeader("Content-Encoding", "gzip");
                }
                else
                {
                    Response.Filter = new System.IO.Compression.DeflateStream(Response.Filter,
                                                System.IO.Compression.CompressionMode.Compress);
                    Response.Headers.Remove("Content-Encoding");
                    Response.AppendHeader("Content-Encoding", "deflate");
                }


            }

            // Allow proxy servers to cache encoded and unencoded versions separately
            Response.AppendHeader("Vary", "Content-Encoding");
        }
        //public override void OnActionExecuting(System.Web.Http.Controllers.HttpActionContext actionContext)
        //{
        //    //// Analyze the list of acceptable encodings
        //    //var preferredEncoding = GetPreferredEncoding(HttpContext.Current.Request);

        //    //// Compress the response accordingly
        //    //var response = HttpContext.Current.Response;
        //    //response.AppendHeader("Content-encoding", preferredEncoding.ToString());

        //    //if (preferredEncoding == CompressionScheme.Gzip)
        //    //{
        //    //    response.Filter = new GZipStream(
        //    //      response.Filter, CompressionMode.Compress);
        //    //}

        //    //if (preferredEncoding == CompressionScheme.Deflate)
        //    //{
        //    //    response.Filter = new DeflateStream(response.Filter, CompressionMode.Compress);
        //    //}
        //    //return;
        //    ////base.OnActionExecuting(actionContext);
        //}

        //static CompressionScheme GetPreferredEncoding(HttpRequest request)
        //{
        //    var acceptableEncoding = request.Headers["Accept-Encoding"];
        //    //acceptableEncoding = SortEncodings(acceptableEncoding);

        //    // Get the preferred encoding format 
        //    if (acceptableEncoding.Contains("gzip"))
        //        return CompressionScheme.Gzip;
        //    if (acceptableEncoding.Contains("deflate"))
        //        return CompressionScheme.Deflate;

        //    return CompressionScheme.Identity;
        //}

        //static String SortEncodings(string header)
        //{
        //    // Omitted for brevity
        //}
    }
    enum CompressionScheme
    {
        Gzip = 0,
        Deflate=1,
        Identity=2
    }
}